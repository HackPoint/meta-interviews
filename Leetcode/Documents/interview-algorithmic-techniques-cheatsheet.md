# ðŸ§  Algorithmic Techniques Cheat Sheet

| Technique                   | When to Use                                                      | Key Clues / Keywords                                               |
|----------------------------|-------------------------------------------------------------------|--------------------------------------------------------------------|
| **Two Pointers**           | Efficiently process sorted arrays or scan from both ends          | "Find pair", "Sorted array", "Remove duplicates", "Palindrome"     |
| **Sliding Window**         | Track dynamic substrings or subarrays in linear time              | "Longest substring", "Fixed size", "At most/least k", "Window"     |
| **Fast & Slow Pointers**   | Detect cycles in linked structures, find middle/duplicates        | "Cycle in list", "Repeated number", "Loop detection", "Midpoint"   |
| **Prefix Sum**             | Efficient subarray sum queries, range-based counting              | "Sum between indices", "Number of subarrays", "Cumulative sum"     |
| **Difference Array**       | Efficiently apply range updates                                   | "Increment range updates", "Range addition"                        |
| **Hash Map / Set**         | Constant-time lookup or frequency counting                        | "Find duplicates", "Grouping", "Character frequency"               |
| **Sorting**                | Group, compare, or make greedy decisions                          | "Sort before comparing", "Minimum moves", "Group anagrams"         |
| **Binary Search**          | Find target efficiently in sorted data, numeric answers via search| "Search in sorted array", "Find min/max", "Kth element", "Condition becomes true" |
| **DFS (Depth-First Search)** | Explore all paths, traverse graphs or trees recursively           | "All paths", "Backtracking", "Tree recursion", "Maze"              |
| **BFS (Breadth-First Search)** | Find shortest paths or level order in unweighted graphs         | "Fewest steps", "Minimum moves", "Level order"                     |
| **Topological Sort**       | Order tasks with dependencies in a DAG                            | "Prerequisites", "Task scheduling", "Directed graph"               |
| **Backtracking**           | Explore all valid states with constraints                         | "Generate combinations", "Valid parenthesis", "Undo last step"     |
| **Dynamic Programming (DP)**| Optimize recursive problems with memoization/tabulation          | "Optimal substructure", "Min cost", "Max profit", "Count of ways"  |
| **Greedy**                 | Make the best local choice for global optimum                     | "Earliest/latest", "Maximize/minimize", "No backtracking"          |
| **Divide and Conquer**     | Split problem into halves and combine results                     | "Merge Sort", "QuickSort", "Binary Search", "Segment Tree"         |
| **Bit Manipulation**       | Solve with binary operations or optimize space                    | "Bitmask", "XOR trick", "Unique element", "Flip/set/check bit"     |
| **Union-Find (DSU)**       | Efficiently track and merge disjoint sets                         | "Connected components", "Cycle detection", "Merge groups"          |
| **Trie**                   | Efficient prefix-based lookup in strings                          | "Prefix search", "Auto-complete", "Word dictionary"                |
| **Heap / Priority Queue**  | Quickly access min/max element                                    | "Top K elements", "Dijkstra", "Sort partially", "Greedy"           |
| **Monotonic Stack**        | Solve problems involving next greater/smaller elements            | "Next greater element", "Histogram", "Stock span", "Sliding max"   |
| **Monotonic Queue**        | Maintain sliding max/min efficiently                              | "Max in window", "Min in window", "Optimized sliding window"       |
| **Segment Tree / BIT**     | Fast range queries and updates                                    | "Range sum/min/max", "Kth order", "Range update/query"             |
| **Matrix Traversal**       | Navigate 2D grids with BFS/DFS, directions array                  | "Island count", "Flood fill", "Grid simulation"                    |
| **Graph Algorithms**       | Handle connections, paths, reachability                          | "DFS/BFS", "Topological sort", "Dijkstra", "Kruskal", "Prim"       |
| **Recursion**              | Solve by breaking into self-similar subproblems                   | "Tree problems", "DFS", "Backtracking", "Divide & Conquer"         |
| **Mathematical Techniques**| Use number theory, primes, GCD/LCM, modulo, combinatorics         | "Factorial", "Binomial coefficient", "Euclidean algorithm"         |
| **Counting / Frequency**   | Count elements/frequencies for optimization or validation         | "Majority element", "Valid anagram", "Character counts"            |
| **Simulation**             | Step-by-step process simulation                                   | "Game of Life", "Rotting oranges", "String shifting"               |
| **State Compression**      | Represent states efficiently using bits                           | "Bitmask DP", "Subset DP", "All combinations with bit tricks"      |
| **Knapsack**               | Optimize combinations under a constraint                          | "Backpack problem", "0/1 knapsack", "Bounded/unbounded knapsack"   |
