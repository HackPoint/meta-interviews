> ‚ö†Ô∏è **No code unless explicitly asked for. Explanations only until `code` is requested.**

---

## üß† 1. Understand the Problem

* [ ] What is the **input**?
* [ ] What is the **expected output**?
* [ ] What are the **constraints**? (Size, values, nullability, duplicates)
* [ ] What are **edge cases**?
* [ ] Can you rephrase the problem in your own words?

---

## üß™ 2. Walk Through Examples

* [ ] Try 1‚Äì2 **basic examples** manually.
* [ ] Think of **edge cases** (e.g., empty input, repeated elements, one element).
* [ ] Use the examples to **identify patterns** or subproblems.

---

## üß© 3. Classify the Problem Type

What category does this problem belong to?

* [ ] Array / Matrix
* [ ] String / Sliding Window
* [ ] HashMap / Set / Count
* [ ] Stack / Queue / Monotonic Structure
* [ ] Linked List
* [ ] Tree / DFS / BFS
* [ ] Dynamic Programming
* [ ] Greedy
* [ ] Two Pointers / Binary Search
* [ ] Graph / Topo Sort / Dijkstra / Union-Find
* [ ] Trie / Prefix Tree
* [ ] Heap / Priority Queue
* [ ] Backtracking / Recursion
* [ ] Bit Manipulation / Math

---

## üõ† 4. Decide Your Approach

* [ ] Brute-force idea (first intuition)?
* [ ] Any way to optimize using:

    * [ ] Prefix sum?
    * [ ] Memoization / DP table?
    * [ ] Monotonic stack / deque?
    * [ ] HashMap / Set / Sorting?
    * [ ] Binary search on index or answer?
* [ ] Can you **preprocess** or transform the data?

---

## üßÆ 5. Analyze Time and Space Complexity

* [ ] Time complexity: O(?)
* [ ] Space complexity: O(?)
* [ ] Is it acceptable under the constraints?

---

## üßº 6. Optimize

* [ ] Can it be done in 1-pass?
* [ ] Can you reduce space (e.g. span, in-place, bit tricks)?
* [ ] Can you avoid recursion?
* [ ] Any early exits or pruning?

---

## ‚úÖ 7. Validate Final Approach

* [ ] Covers all examples and edge cases?
* [ ] Meets performance constraints?
* [ ] Clean, readable logic?

---

## ‚öôÔ∏è 8. Implementation (Only When `code` Is Requested)

> ‚ùå No code unless explicitly asked!

When you say `code`, we will:

* Implement with C# best practices
* Use `Span` or `stackalloc` for perf
* Benchmark if needed

---

Let me know the next problem and I‚Äôll follow this structure. You're now working like a Meta-level engineer.
